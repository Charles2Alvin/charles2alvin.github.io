<h2>JVM 常见面试问题（二）</h2>

<h3>&lt;1⃣️判断Java对象的存活&gt;</h3>

<h4>引用计数法</h4>

<ol><li>实现：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，引用失效时，计数器减1</li><li>JVM不使用这个方法来回收内存，因为它很难解决对象之间相互循环引用的问题</li></ol>

<h4>可达性分析算法</h4>

<ol><li>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当GC Roots到一个对象不可达时，此对象不可达时，此对象被判定为是可回收的对象</li><li>可作为GC Roots的对象：<ul><li>虚拟机栈的栈帧中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li><li>不可达的对象不是非死不可的，而是暂时处于“缓刑”阶段<ul><li>可达性分析发现一个对象不可达时，它会被第一次标记，并且进行筛选，留下有必要执行finalize()方法的</li><li>当对象没有覆盖finalize()方法，或者finalize()方法已经被VM调用过，都会被视为没有必要执行</li><li>如果这个对象被判定为有必要执行finalize()方法，就会被放置在F-Queue队列中，由一个VM自动建立的低优先级的Finalizer的线程，触发这个finalize()方法</li><li>关于finalize()方法，<ul><li>如果该对象与引用链上的任何一个对象建立了关联，那它会被移出“即将回收”的集合</li><li>否则，它就真的被回收了</li><li>注意，一个对象的finalize()方法只能被调用一次，所以只能自救一次</li><li>这个方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，最好不要用</li></ul></li></ul></li></ol>

<h4>引用的类型</h4>

<ol><li>强引用<ul><li>类似Object obj = new Object()之类的引用</li><li>只要强引用还存在，GC永远不会回收掉被引用的对象</li></ul></li><li>软引用<ul><li>用来描述一些有用但非必需的对象</li><li>在系统将要发生OOM之前，会把这些对象列进回收范围进行第二次回收，如果这次回收还没有足够的内存，才会抛出OOM异常</li></ul></li><li>弱引用<ul><li>强度比软引用更弱，当GC工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象</li><li>只能生存到下一次GC发生以前</li></ul></li><li>虚引用（Phantom Reference）<ul><li>为一个对象设置引用关联的唯一目的就是能在这个对象被GC回收时收到一个系统通知</li><li>一个对象是否持有虚引用，不影响其生存时间</li></ul></li></ol>

<h4>方法区（永久代）的垃圾回收</h4>

<ol><li>方法区主要回收的是两部分内容：废弃常量和无用的类</li><li>判断一个类是否是无用的类<ol><li>该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法</li></ol></li><li>判断一个常量是否是废弃常量：该常量没有在任何地方被引用</li><li>判断为可以回收的类也不一定会被回收</li></ol>

<h3>&lt;2⃣️JVM 垃圾收集算法&gt;</h3>

<h4>标记-清除算法(Mark-Sweep)</h4>

<ol><li>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</li><li>是最基础的收集算法，后续的收集算法都是基于这种思路改进其不足得到的</li><li>不足之处：<ol><li>效率低：标记和清除的效率都不高</li><li>空间问题：标记清除后会产生大量不连续的内存碎片，可能会导致以后需要分配大对象时因为内存不够而提前触发一次GC</li></ol></li></ol>

<h4>复制算法(Copying)</h4>

<ol><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</li><li>当这一块用完之后，将还存活的对象复制到另一块上面</li><li>实现简单，运行高效，代价是内存缩小为原来的一半</li><li>商业VM将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将Eden和Survivor中还存活的对象复制到另外一块Survivor空间上，最后清理Eden和用过的Survivor空间；如果这块Survivor装不下，存活对象就会通过分配担保机制进入老年代</li></ol>

<h4>标记-整理算法(Mark-Compact)</h4>

<ol><li>标记过程和标记-清除算法一样，后续会让所有存活对象都向一端移动，然后清理掉边界以外的内存</li></ol>

<h4>分代收集算法(Generational Collection)</h4>

<ol><li>根据对象存活周期的不同将内存划分为几块，一般就是把Java堆划分为新生代(Young generation)和老年代(Tenured generation)，根据各个年代的特点采用最适当的收集算法</li><li>新生代中，每次GC只有少量对象存活，就使用复制算法；老年代中对象存活率高，没有额外空间对它进行分配担保，必须使用标记-清理或者标记-整理算法来回收。</li></ol>

<h3>&lt;3⃣️垃圾收集器&gt;</h3>

<ul><li>知道现在为止还没有最好的收集器，更没有万能的收集器</li><li>根据实际应用选择最合适的收集器</li><li>所以HotSpot虚拟机实现了很多收集器</li><li>对于GC Collector而言，并发和并行的概念：<ul><li>并行：多条垃圾收集线程并行工作，此时用户线程处于等待状态</li><li>并发：用户线程与垃圾收集线程同时执行，运行在不同的CPU上</li></ul></li></ul>

<h4>Serial收集器</h4>

<ul><li>是一个单线程的收集器，只会用一个CPU/一条收集线程工作</li><li>工作时必须暂停其他所有的工作线程，直到它收集结束</li><li>是VM运行在Client模式下的默认新生代收集器</li></ul>

<h4>ParNew收集器</h4>

<ul><li>Serial收集器的多线程版本</li><li>运行在Server模式下的VM首选的新生代收集器，因为只有它能与CMS收集器配合工作</li><li>第一款真正意义上的并发收集器</li></ul>

<h4>Parallel Scavenge收集器</h4>

<ul><li>与ParNew非常相似，但是<ul><li>关注点在于达到一个<strong>可控制的吞吐量</strong>， 适合在后台运算、交互少的任务</li><li>其他收集器关注的是尽可能<strong>缩短用户线程的停顿时间</strong>，适合需要与用户交互的任务</li></ul></li><li>吞吐量举例，VM运行了100min，GC花掉1min，吞吐量就是99%</li><li></li></ul>